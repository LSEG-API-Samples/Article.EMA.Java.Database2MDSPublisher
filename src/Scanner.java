/** Scanner watches and expects file to be in format:
 *	ItemName,data1,data2...datan
 * 	There should be same number of corresponding FID[] defined in this class
 */


import java.io.IOException;
import java.nio.file.*;
import java.io.*;
import java.util.*;
import static java.nio.file.StandardWatchEventKinds.*;
 
public class Scanner {
	
	// list of fids which correspond to data in the file generated by database
	// first FID corresponds to instrument name and is unused and initialized to 0
	static final Integer FIDS[] = {0, 22, 25};
	
	private Provider connectedProvider;
	private WatchService watcher;
	private Path watchedDir;
	
	Scanner(Provider prov, String directory) throws Exception	{
		this.connectedProvider = prov;

		// create a file watcher and listen for new files
		watchedDir = Paths.get(directory);
		watcher = FileSystems.getDefault().newWatchService();
		watchedDir.register(watcher, ENTRY_CREATE);
		System.out.println("Started monitoring: " + watchedDir); 
	}


	public void startScanning()	 throws Exception	{
		while(true)	{
			// blocking call while waiting for a file
			WatchKey key = watcher.take();

			// new key received
			for (WatchEvent<?> event : key.pollEvents()) {
				WatchEvent.Kind<?> kind = event.kind();

				@SuppressWarnings("unchecked")
				Path fileName = ((WatchEvent<Path>) event).context();
				System.out.println("Processing file: " + fileName);

				// if a new file was dropped into the monitored directory
				if (kind == ENTRY_CREATE) {
					Path filePtr = watchedDir.resolve(fileName);
					Thread.sleep(500);
					// publish the data in the file
					parseAndPublish(filePtr);
					Thread.sleep(500);
					// remove the file which has been processed
					Files.delete(filePtr);
				}
			}

			// restart monitoring
			key.reset();
		}
	}


	private void parseAndPublish(Path fileName)	 throws Exception	{
		// read the data from this file
		BufferedReader reader = Files.newBufferedReader(fileName);
		HashMap<Integer, Integer> data = new HashMap<Integer, Integer>();
		String rLine;
		
		while((rLine = reader.readLine()) != null)	{
			// parse all lines and extract name and fid values
			String tokens[] = rLine.split(",");
			if(tokens.length < FIDS.length)	{
				// invalid number of csv entries in this line
				System.err.println("Unable to parse data in line: " + rLine);
				continue;
			}
			
			// populate map with FID/values
			for(int idx = 1; idx < tokens.length; idx++)	{
				int fpOffsetData = (int) (Double.valueOf(tokens[idx]) * 100);
				data.put(FIDS[idx], fpOffsetData);
			}
			
			// hand over this map to provider class for publishing
			connectedProvider.publish(tokens[0], data);
			data.clear();
		}
		
		reader.close();
	}

}
